---
slug: /guides/rsocket-py/server
title: RSocketServer - rsocket-py
sidebar_label: Introduction
---

`RSocketServer` is the high level abstraction leveraged to create a server running the RSocket protocol.

An `RSocketServer` server can be used to communicate with any RSocket Client implemented against the same protocol version as the server,
and which implements the same transport as the server.

To get started creating an RSocket server, you will need to install the [rsocket](https://pypi.org/project/rsocket/) package,
and atleast one transport protocol implementation. See the server portion of [WebSocket Client Server Example](/guides/rsocket-py#server-example)
for an example of an implemented `getRequestHandler`.

## Transports

A transport is the abstraction which handles the underlying network communication portion of the RSocket applicaiton protocol.

Available network transports for `RSocketServer` include:

- TCP - available by default
- Websocket
  - aiohttp
  - Quart

## `RequestHandler`

When creating a `RSocketServer` instance, the constructor require a factory (method or class) be provided that can
return an object matching the `RequestHandler` abstract class.
This object is responsible for mapping callback/handler functions to the various RSocket message types,
and returning an appropriate Publisher/Future that will produce data for the request.

```py
from asyncio import Future
from typing import Tuple

from reactivestreams.publisher import Publisher
from reactivestreams.subscriber import Subscriber
from rsocket.payload import Payload
from rsocket.request_handler import RequestHandler


class CustomRequestHandler(RequestHandler):

    async def on_setup(self,
                       data_encoding: bytes,
                       metadata_encoding: bytes):
        ...

    async def request_channel(self, payload: Payload) -> Tuple[Publisher, Subscriber]:
        ...

    async def request_fire_and_forget(self, payload: Payload):
        ...

    async def on_metadata_push(self, payload: Payload):
        ...

    async def request_response(self, payload: Payload) -> Future:
        ...

    async def request_stream(self, payload: Payload) -> Publisher:
        ...
```

## Client Cancellation

An important characteristic of RSocket's protocol is the concept of cancellation.

In the context of an RSocket server, once a client connection/request has begun, it is possible that the client which
initiated the request may decide it no longer wishes to continue and signal to the server that it wishes to cancel.

In the event that a client signals to an RSocket server that it wishes to cancel a request, the server should avoid
calling the `onComplete` or `onNext` callbacks for the requests resulting [`Single`](../rsocket-rxpy/single.mdx)
or [`Flowable`](../rsocket-rxpy/flowable.mdx) instances.

### Cancellation Example

```py
from reactivestreams.publisher import Publisher
from reactivestreams.subscription import Subscription
from reactivestreams.subscriber import Subscriber
from rsocket.payload import Payload
from rsocket.request_handler import BaseRequestHandler

class CustomRequestHandler(BaseRequestHandler):

    class StreamPublisher(Publisher, Subscription):
        def subscribe(self, subscriber: Subscriber):
            ...

        async def request(self, n: int):
            ...

        def cancel(self):
            ...

    async def request_stream(self, payload: Payload) -> Publisher:
        return self.StreamPublisher()


const statuses = {
  PENDING: 'pending',
  CANCELLED: 'cancelled',
};

const getRequestHandler = (requestingRSocket, setupPayload) => {
  function handleRequestResponse(payload) {
    const simulatedDelayMilli = 100;
    let status = statuses.PENDING;

    return new Single((subscriber) => {
      /**
       * In the event that the client cancels the request before
       * the server can respond, we will change our status to cancelled
       * and avoid calling `onComplete` on the `subscriber` instance in the
       * `nextTick` callback.
       */
      function handleCancellation() {
        status = statuses.CANCELLED;
      }

      subscriber.onSubscribe(() => handleCancellation());

      /**
       * Leverage `setTimeout` to simulate a delay
       * in responding to the client, and thus giving it
       * time to decide to "cancel".
       */
      setTimeout(() => {
        /**
         * If the client cancelled the request we can
         * return early and avoid doing any of the work below.
         */
        if (status === statuses.CANCELLED) {
          return;
        }

        const msg = `${new Date()}`;
        try {
          subscriber.onComplete({
            data: msg,
            metadata: null,
          });
        } catch (e) {
          subscriber.onError(e);
        }
      }, simulatedDelayMilli);
    });
  }

  return {
    requestResponse: handleRequestResponse,
  };
};
```
